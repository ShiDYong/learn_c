/**
Created by mason on 2023/5/28
 第七章课后练习题目
 *
*/
#include<stdio.h>

/**
 * 八、十、十六、二进制转换在C语言中体现:
 * 具体详细操纵看案例链接：https://www.cnblogs.com/gaizai/p/4233780.html
 */
void exec07_01() {
    /*1.二进制 → 十进制
     * 方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，
     * 第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。
     * 　　例：将二进制的(101011)B转换为十进制的步骤如下：
     *  1. 第0位 1 x 2^0 = 1；
        2. 第1位 1 x 2^1 = 2；
        3. 第2位 0 x 2^2 = 0；
        4. 第3位 1 x 2^3 = 8；
        5. 第4位 0 x 2^4 = 0；
        6. 第5位 1 x 2^5 = 32；
        7. 读数，把结果值相加，1+2+0+8+0+32=43，即(101011)B=(43)D。
     */
    /*八进制 → 十进制
　　方法：八进制数从低位到高位（即从右往左）计算，第0位的权值是8的0次方，第1位的权值是8的1次方，第2位的权值是8的2次方，依次递增下去，
     把最后的结果相加的值就是十进制的值了。
　　八进制就是逢8进1，八进制数采用 0～7这八数来表达一个数。
　　例：将八进制的(53)O转换为十进制的步骤如下：
    1. 第0位 3 x 8^0 = 3；
    2. 第1位 5 x 8^1 = 40；
    3. 读数，把结果值相加，3+40=43，即(53)O=(43)D。
     * */
    int a = 077;
    printf("%u\n", a);

    /*
     * 十六进制 → 十进制
　　方法：十六进制数从低位到高位（即从右往左）计算，第0位的权值是16的0次方，第1位的权值是16的1次方，第2位的权值是16的2次方，
     依次递增下去，把最后的结果相加的值就是十进制的值了。
　　十六进制就是逢16进1，十六进制的16个数为0123456789ABCDEF。
　　例：将十六进制的(2B)H转换为十进制的步骤如下：
    1. 第0位 B x 16^0 = 11；
    2. 第1位 2 x 16^1 = 32；
    3. 读数，把结果值相加，11+32=43，即(2B)H=(43)D。
     *
     * */
    int c = 0x77;
    printf("%hd\n", c);
    int d = 0XABC;
    printf("%hd\n", d);


}

/**
 * 案例2:下列哪些常量在c语言中不是合法的？区分每一个合法的常量是整数还是浮点数。
 */
void exec07_2_3() {
    float a = 010E2;
    float b = 32.1E+5;
    // int c = 0790; //C语言中基本数据类型0开头表示的8进制，八进制的范围：0-7，这里明显数据到达了9
    // int d = 100_000; 这种写法也是错误的
    float f = 3.978e-2;

    //下列哪些类型在C语言中是不是合法的？
    short unsigned int;
    // short float; //不是一种合法的类型。唯一可用的浮点类型
    // ' float '， ' double '和' long double '。
    long double;
    unsigned long;

}

/**
 * 课后习题04:如果变量c是char类型，那么下列那条语句是非法的？
 */
void exec07_04() {
    int i = 1;
    char c = 'a';
    //a.
    i += c;
    printf("%d\n", i);
    //b.
    c = 2 * c - 1;
    //c.
    putchar(c); //输出的是乱码的
    printf("%d\n", c);

    //d.
    //printf(c); 不合法的，因为printf函数打印的String字符串，
    //不是单个(数字表示的)字符;

}

/**
 * 课后练习题9-12题目:
 * 知识点：C语言数据类型转换（自动类型转换+强制类型转换）
 * 具体案例分析链接：http://c.biancheng.net/view/1775.html
 *
 */
void exec07_09_12() {
    /*10.假设变量i是int类型，变量j是long int 类型，并且变量k是unsigned int类型，那么表达式
     i+(int)j *k 是什么类型？*/
    int i;
    long int j;
    unsigned int k;
    i + (int) j * k;  //(int) j强制类型转换成int, 与k相乘后:（int）j * k整体编程了:unsigned int
    //i + (int)j * k整体变成了unsigned int无符号整型;
    //自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生
    //在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型转换为左边变量的类型，这可能会导致数据失真，或者精度降低；所以说，自动类型转换并不一定是安全的。对于不安全的类型转换，编译器一般会给出警告。
    //float f = 100;int n = f;f 是 float 类型的数据，需要先转换为 int 类型才能赋值给变量 n。

    //2) 在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下：
    //转换按数据长度增加的方向进行，以保证数值不失真，或者精度不降低。例如，int 和 long 参与运算时，先把 int 类型的数据转成 long 类型后再进行运算。
    //所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。
    //char 和 short 参与运算时，必须先转换成 int 类型。
    /*
     * char
     *         int-> unsigned int ->long ->double <-float
     * short
     *
     * */
    printf("%d\n", sizeof(i + (int) j * k));//打印四个字节

    /*9.假设变量a和变量b都是int类型，那么表达式i/j + 'a'是什么类型？*/
    int a, b;
    char ch = 'a';
    printf("%d\n", sizeof(a / b + ch)); // i/j是int,ch是char要自动提升至int

    /*11.假设变量h是int类型,变量f是float类型，变量d是double类型，那么表达式i * f / d是什么类型？*/
    int h;
    float f;
    double d;
    printf("%d\n", sizeof(i * f / d)); //所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算
    /*12.假设变量m是int类型，变量y是float类型，变量n是double,请解释在执行下列语句时发生了什么转换？*/
    int m;
    float y;
    double n;
    n = m + y; //m自动提升成float,m+y转换成double类型，


}

/**
 * 课后练习13:假设程序包含下列声明：
 * 请给出每个表达式的值和类型：
 */
void exec07_13() {
    char c = '\1';
    short s = 2;
    int i = -3;
    long m = 5;
    float f = 6.5f;
    double d = 7.5;
    //a
    c * i; //-3,int 类型
    //b
    f / c; //6.5f,float类型
    //c
    f - d; //-1.0,double 类型
    //d
    s + m; //7,long类型
    //e
    d / s; //3.75,double类型
    //f
    (int) f;//6是int类型
    printf("%d\n", (int) f);
}

/**
 * 课后编程练习14:下列语句是否总是可以正确地计算出小数部分(假设f和frac_part都是float类型的变量？)
 * frac_part = f -(int) f;
 * 如果不是，那么出了什么问题？
 */
void exec07_14() {
    float frac_part, f = 88990909004.50f;
    frac_part = f - (int) f; //如果' f '的值大于int最大值，语句可能会失败，所以进行强制转换时需要注意
    printf("%f\n", frac_part); //int 到 char * 就是风险极高的一种转换，一般会导致程序崩溃。
    //无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值


}

/**
 * 课后编程练习题15:使用typedef创建名为Int8、Int16和Int32的类型。定义这些类型，使它们可以在你的机器上分别表示8位、
 * 16位和32位的整数
 */
void exec07_15() {
    typedef char Int8;  //char 占一个字节:8位内存
    typedef short Int16; //short 占2个字节的内存：16位
    typedef int Int32;  //int 占4个字节的内存：32位


}

//int main() {
    //exec07_01();
    //  exec07_04();
    //exec07_09_12();
    //exec07_13();
   // exec07_14();
  //  return 0;
//}