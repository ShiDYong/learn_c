/********************************************************************************
* @author: mason shi
* @date: 2023/7/7 22:02
* @version: 1.0
* @description: 第二章：指针和数组
 *              第11章介绍了如何把指针用作函数的实际参数和函数的返回值。本章介绍指针的另一种运用。当指针指向数组元素时，C语言允许对指针
 *              进行算术运算(加法和减法)，通过这种运算我们可以用指针代替数组下标对数组进行运算。
 *              理解指针和数组之间的关系对于掌握C语言非常关键：它使我们深入了解C语言的设计过程，并且能力帮助我们理解现有的程序。
 *              然后，需要知道的是，用指针处理数组的主要原因是效率。但是这里的效率提升已经不再像当初那么重要了，这主要归功于
 *              编译器的改进.
********************************************************************************/
#include<stdio.h>

#define N 10

void cases_12_1();

void cases_12_2();

void cases_12_2_reverse();

void cases_12_3_1();

int find_largest(int a[], int n);

int find_largest_pointer(int *a, int n);


/*
int main() {

    // cases_12_1();
    // cases_12_2();
    //cases_12_2_reverse();
    cases_12_3_1();
    return 0;
}

*/

/**
 * 12.1:介绍指针的算术运算，并且说明如何使用关系运算符和判等运算符进行指针的比较
 */
void cases_12_1() {
    //12.1指针的算术运算：指针可以指向数组
    int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, *p, *q;
    //使p指向a[0]
    printf("%d\n", a[0]);
    p = &a[0];
    //可以通过p访问a[0]并对a[0]值进行改写
    *p = 5; //此时a[0]=5
    printf("%d\n", a[0]);

    /**
     * 12.1通过在p上进行指针算术运算(或各种地址运算)，可以访问数组a的其他所有元素。C语言支持3种(而且只有三种)
     * 格式的指针算术运算：
     * 1.指针加上整数；
     * 2.指针减去整数；
     * 3.两个指针相减。
     * */

    //12.1.1指针加上整数：指针p加上整数j产生指向特定元素的指针，这个特定元素是p原先指向的元素后的j个位置。更确切地说。如果p指向数组
    //元素a[i]，那么p+j指向a[i+j](当然，前提是a[i+j]必须存在)
    p = &a[2];
    q = p + 3;
    printf("%p\n", q);  //内存地址是一样的，值也是一样的
    printf("%p\n", &a[5]);
    printf("%d\n", *q);
    printf("%d\n", a[5]);
    p += 6;
    printf("%d\n", *p);
    printf("%d\n", a[8]);
    //12.1.2指针减去整数:如果p指向数组元素a[i],那么p-j指向a[i-j].
    p = &a[8];
    q = p - 3;
    p -= 6;
    //12.1.3 连个指针相减：当两个指针相减时，结果为指针之间的距离(两个元素的个数来度量)。因此，如果p指向a[i]且q指向a[j]
    //那么p-q就等于i-j
    p = &a[5];
    q = &a[1];
    int i = p - q;//i is 4
    i = q - p;//i is -4
    //在一个不指向任何数组元素的指针上执行算术运算会导致未定义的行为，此外，只有两个指针指向同一个数组时，把它们相减才有意义
    //12.1.4:指针比较可以利用运算符(<、<=、>和>=)和判等运算符(==和!=)进行指针比较。只有两个指针指向同一数组时，用关系运算符进行的
    //指针比较才有意义。比较的结果依赖于数组中两个元素的相对位置。例如，在下面的赋值后p<=q的值是0,而p>=q的值是1.
    p = &a[5];
    q = &a[1];

    //12.1.5指向复合字面量的指针:指针指向复合字面量创建的数组中某个元素是合法的。
    int *m = (int[]) {3, 0, 3, 4, 1};
    //p指向一个5元素数组的第一个元素，这个数组包括5个整数：3、0、3、4和1.使用复合字面量可以减少一些麻烦，我们
    //不再需要先声明数组变量，然后用指针p指向数组的第一额元素.

}

/**
 * 12.2用数组名作为指针：指针的算术运算是数组和指针之间的相互关联的一种方法。但这不是两者之间唯一的联系。
 * 另外一种联系：可以用数组的名字作为指向数组第一个元素的指针。这种关系简化了指针的算术运算，而且使数组和指针更加通用
 */
void cases_12_2() {
    int a[10];
    //用a作为指向数组第一个元素的指针，可以修改a[0]
    *a = 7;/*stores 7 in a[0]*/
    printf("%d\n", a[0]);
    printf("%d\n", *a);
    //可以通过指针a+1来修改a[1]
    *(a + 1) = 12;/*store 12 in a[1]*/
    printf("%d\n", a[1]);
    printf("%d\n", *a);  //a[0]的值

    /*通常情况下，a+i等同于&a[i](两者都表示指向数组a中元素i的指针)，并且*a(a+1)等价于a[i]
     * 两者都表示元素i本身。换句话说，可以把数组的取下标操作看作指针算术运算的一种形式
     * 数组名可以用作指针这一事实使得编写遍历数组的循环更加容易。
     * */
    int *p, sum;
    for (p = a; p < a[N]; p++) {
        sum += *p; //进行求和
    }
    //上面的方式可以进一步简化:可以用a替换&a[0],同时使用a+N替换掉&a[N];
    for (p = a; p < a + N; p++) {
        sum += *p;
    }
    //⚠️：虽然可以把数组名用作指针，但是不能给数组名赋新值。试图使数组名指向其他地方是错误的：
    while (*a != 0)
        //  a++;  /*会报错*/
        //这一限制不会对我们造成什么损失，我们可以把a复制给一个指针变量，然后改变该指针变量
        p = a;
    while (*p != 0)
        p++;


}


/**
 * 案例练习：数组反向(改进版本)
 * 8.1节的程序reverse.c读入10个数，然后逆序输出这些数。程序读取数时会把这些数存入数组。一旦所有的数都读入了，程序就会反向遍历数组并
 * 打印出这些数。原来的程序利用下标来访问这些数组中的元素。下面要求用指针的算术运算取代来数组的下标操作。
 */
void cases_12_2_reverse() {
    int arr[N], *p;
    printf("Enter %d numbers: ", N);
    for (p = arr; p < arr + N; p++)
        scanf("%d", p);/*注意第二个参数是p，不是&p。因为p指向数组的元素，所以它满足scanf函数要求的参数；而&p则是指向“指向数组元素的
 * 的指针”的指针*/
    //逆序遍历数组并输出元素
    for (p = arr + N - 1; p >= arr; p--)/*在原先的程序中，整型变量i用来记录数组内的当前位置，新版程序用指针变量p替换了i*/
        printf(" %d", *p);
    printf("\n");

}


/**
 * 12.3.1数组型实际参数
 */
void cases_12_3_1() {
    //假设调用find_largest()函数如下：
    int b[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    //  printf("返回的最大值：%d\n", find_largest(b, N));
    //数组时被修改为0，打印验证
//    for (int i = 0; i < N; ++i)
//        printf(" %d", b[i]); // 0 0 0 0 0 0 0 0 0 0
    printf("返回的最大值：%d\n", find_largest_pointer(&b, N));
    for (int i = 0; i < N; ++i)
        printf(" %d", b[i]); // 0 0 0
    /*
     * 这个调用会把指向数组b第一个元素的指针赋给a，数组本身并没有被复制。
     * 把数组形式参数看作指针会产生许多重要的结果：
     * 1.在给函数传递普通变量时，变量的值会被复制。任何对相应的形式参数的改变都不会影响到变量。反之
     * 因为没有对数组本身进行复制，所以作为实际参数的数组时可能被改变的。如下：可以通过在数组的每个元素中存储零来修改数组
     * {
     * int i;
     * for(i=0; i<n; i++)
     *      a[i]=0;}
     * 为了指明数组型形式参数不会给改变，可以在其声明中包含单词const;
     * 2.给函数传递数组所需的时间与数组的大小无关。因为没有对数组进行复制，所以传递大数组不会产生不利的结果。
     * 3.如果需要，可以把数组型参数声明为指针：
     *
     * */

    //可以给形式参数为数组的函数传递数组的片段，所谓片段是指连续的数组元素组成的序列。比如；
    find_largest_pointer(&b[5],10);
    //12.3.2用指针作为数组名:既然可以用数组名作为指针，C语言是允许把指针看作是数组名进行取下标操作



}


/**
 * 返回整型数组中最大的元素方法
 * @param a
 * @param n
 * @return
 */
int find_largest(int a[], int n) {
    int i, max;
    for (i = 0; i < n; i++)
        if (a[i] > max)
            max = a[i];
    /*1.在给函数传递普通变量时，变量的值会被复制。任何对相应的形式参数的改变都不会影响到变量。反之
     * 因为没有对数组本身进行复制，所以作为实际参数的数组时可能被改变的
     * 下面把数组b全部的值改为0*/
    for (i = 0; i < n; i++)
        a[i] = 0;
    return max;

}

int find_largest_const(const int a[], int n) {
    int i, max;
    for (i = 0; i < n; i++) {
        if (a[i] > max)
            max = a[i];
    }

    /*1.在给函数传递普通变量时，变量的值会被复制。任何对相应的形式参数的改变都不会影响到变量。反之
     * 因为没有对数组本身进行复制，所以作为实际参数的数组时可能被改变的
     * 下面把数组b全部的值改为0*/
    /*为了指明数组形式参数不会被改变，可以在其声明中包含单词const
     * 如果参数中包含有const，编译器会核实find_largest_const函数体中确实没有对a中元素赋值。
     * */
    /*  for (i = 0; i < n; i++)
          a[i] = 0;*///这里编译会提示报错
    return max;

}

/**
 * 可以把数组型参数声明为指针
 * @return
 */
int find_largest_pointer(int *a, int n) {
    int *p = a, max = *p;
    for (p; p < a + n; p++)
        if (*p > max)
            max = *p;
    return max;
    /*声明a是指针相当于声明它是数组。编译器会把这两类声明看作完全一样的
     * 对于形式参数而言，声明为数组跟声明为指针是一样的；但是对变量而言，声明为数组跟声明为指针是不同的
     * int a[10];会导致编译器预留10个整数的空间，但声明：
     * int *a;
     * 只会导致编译器为一个指针变量分配空间。在后一种情况下，a不是数组，试图把它当作数组使用可能会导致极糟糕的
     * 后果,如：
     * *a;
     * 将在a指向的地方存储0.因为我们不知道a指向哪里，所以对程序的影响是不可预料的
     * */


}
