/********************************************************************************
* @author: mason shi
* @date: 2023/7/9 10:15
* @version: 1.0
* @description: 第九章已经介绍过了函数，因此本章就来讨论一个程序包含多个函数时所产生的几个问题。本章的前两节讨论局部变量和外部变量之间的差异
 *              ，10.3节考虑程序块问题，10.4节解决用于局域名、外部名和在程序块中声明的名字作用域规则问题、10.5节介绍用来组织函数原型、函数定义
 *              、变量声明和其他程序部分的问题。
********************************************************************************/
#include<stdio.h>
#include<stdbool.h>

#define STACK_SIZE 10
int cases10_1_sum_digits(int n);

void static stack_overflow();

void stack_underflow();

void print_one_row(void);

void print_all_rows(void);

void case10_4_scope();


/**
    * 为了说明外部变量的使用方法，下面通过栈(stack)的数据结构实现。
    * 栈是抽象的概念，它不是C语言的特性，大多数编程语言都可以实现栈。像数组一样，栈可以存储具有相同数据类型的多个数据项
    * 。然后，栈的操作是受限：只可以往栈中压入数据项(把数据项加在一端“栈顶”)或者从栈中弹出数据项(从同一端移走数据项).禁止
    * 测试或修改不再栈顶数据项。
    */
int contents[STACK_SIZE];  /*external variables,把数据项或叫做元素存储在该数组中*/
int top = 0;  //栈的全局变量，用来标记栈顶的位置

int main() {
//    int n = 128;
//    cases10_1_sum_digits(n);
//    print_all_rows();


}


/**
 *
 * 10.1:局部变量
 *      1.在函数体内声明的变量称为该函数的局部变量；
 *      2.默认情况下，局部变量具有下列性质：
 *      自动存储期。变量的存储期(storage duration,也称为延续)是程序执行时，能够保证变量的存储空间必定存在的那一部分时间。通常来说，
 *      局部变量的存储空间是包含该变量的函数被调用时自动分配的，函数返回时收回分配，所以称这种变量具有自动存储期。包含局部变量的函数返回时
 *      局部变量的值无法保留。当再次调用该函数时，无法保证变量仍拥有原先的值。
 *      块作用域：变量的作用域时可以引用该变量的那一部分程序文本。局部变量拥有块作用域：从变量声明的点开始一直到所在函数体的末尾，因为局部
 *      变量的作用域不能延伸到其所属函数之外，所以其他函数可以把同名变量用于别的用途。
 * @param n
 * @return
 */
int cases10_1_sum_digits(int n) {
    int sum = 0;  /*local variable*/
    while (n > 0) {
        sum += n % 10;
        n /= 10;
    }

    /**10.1.1静态局部变量：
     * 在局部变量声明中放置单词static可以使变量具有静态存储期而不再是自动存储期。因为静态存储期的变量拥有永久的存储单元，
     * 所以整个程序执行期间都会保留变量的值;
     * 因为局部变量i已经声明为static，所以在程序执行期间它所占的内存单元是不变的，在f返回时，变量i不会丢失其值；
     * 静态局部变量始终有块作用域，所以它对其他函数是不可见的。概括来说，静态变量是对其他函数隐藏数据的地方，但是
     * 它会为将来的同一额函数的再调用保留这些数据。
     * */
    int static i = 10; /*static local variable*/
    printf("静态变量在函数体内的值:%d\n", i);

    /**
     * 10.1.2: 形式参数拥有和局部变量一样的性质，即自动存储期和块作用域。事实上，形式参数和局部变量唯一真正的区别是
     * 在每次调用函数时对形式参数自动进行初始化(调用中通过赋值获得相应实际参数的值)
     */
    return sum;
}

/**
 * 10.2 外部变量：
 *   传递参数是给函数传送信息的一种方法。函数还可以通过外部变量(external variable)进行通信。外部变量是声明在任何函数体外的。
 *   外部变量(有时成为全局变量)的性质不同于局部变量的形式：
 *   1.静态存储期。就如同声明为static的静态变量一样，外部变量拥有静态存储期。存储在外部变量中的值将永久保留下来；
 *   2.文件作用域。外部变量拥有文件作用域；从变量声明的点开始一直到所在文件的末尾，因此，跟随在外部变量声明之后的所有函数都可以
 *   访问(并修改)它。
 *   以下对应的栈的方法：
 *   1.将栈置为空；
 *   2.判断栈是否为满的？
 *   3.判断栈是否是空的？
 *   4.入栈操作
 *   5.出栈操作
 */
void make_empty() {
    top = 0;
}

bool is_empty() {
    return top == 0;
}

bool is_full() {
    return top == STACK_SIZE;
}

void push(int i) {
    if (is_full())
        stack_overflow();
    else
        contents[top++] = i;
}

int pop(void) {
    if (is_empty())
        stack_underflow();
    else
        return contents[top--];
}


void static stack_overflow() {
    printf("stack_overflow");
}

void stack_underflow() {
    printf("stack_underflow");

}

/**
 * 10.2.2外部变量的利和弊：
 * 在多个函数必须共享一个变量时或者少数几个函数共享大量变量时，外部变量很有用的。然后在大多数情况下，对函数而言，通过形式参数进行
 * 通信比通过共享变量的方法更好，原因如下：
 *      1.在程序维护期间，如果改变外部变量(比如说改变它的类型)，那么需要检查同一个文件中的每个函数，以确认该变化将如何对函数产生影响。
 *      2.如果外部变量被赋予了错误的值，可能很难确定出错的函数；
 *      3.很难在其他程序中复用外部变量的函数。依赖外部变量的函数不是独立的。为了在另一个程序中使用该函数，必须带上此函数需要的外部变量。
 *      以下通过两个函数对比：
 *
 */

/**
 * 把原本应该是局部变量神明为外部变量可能导致一些令人厌恶的错误。下面的方法原本是希望它显示一个由星号组成的10*10的图形；
 * 结果只显示一行。
 */
int i;

void print_one_row(void) {
    for (i = 1; i <= 10; ++i) {
        printf("*");

    }
}

void print_all_rows(void) {
    for (i = 1; i <= 10; ++i) {
        print_one_row();
        printf("\n");

    }
}

/**
 *10.4:作用域
 * 在C程序中，相同的标识符可以有不同的含义。C语言的作用域规则使得程序员可以确定与程序中给定点相关的是那种含义
 * 下面是最重要的作用域规则：当程序块内的声明命名一个标识符时，如果此标识符已经是可见的(因为此标识符拥有文件作用域，或者因为它
 * 已在某个程序块内声明)，新的声明临时隐藏了旧的声明，标识符获得了新的含义。在程序块的末尾，标识符重新获得旧的定义。
 *
  int i;   声明1，i是具有静态存储期和文件作用域的变量
  void f(int i) {
    i = 1;
    }

void g(void) {
    int i = 2;
    if (i > 0) {
        int i;
        i = 3;
    }
    i = 4;
    }

void h(void) {
    i = 5;
    }

 *
 *
 *
 */


